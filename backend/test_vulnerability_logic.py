#!/usr/bin/env python3
"""Test vulnerability scoring logic directly without database imports."""


def normalize_party(party_str):
    """Normalize party coalition to D, R, or Other."""
    if not party_str:
        return "Other"
    party_upper = party_str.upper().strip()
    if party_upper == "D" or "DEM" in party_upper or "WOR" in party_upper:
        return "D"
    elif party_upper == "R" or "REP" in party_upper or "CON" in party_upper:
        return "R"
    else:
        return "Other"


def calculate_vulnerability_score(
    margin_pct: float,
    total_votes: int,
    winner_party: str,
    county: str
) -> float:
    """Calculate strategic vulnerability score for a race.

    Score factors (0-100 scale):
    1. Margin tightness (40% weight) - tighter margins = higher vulnerability
    2. Swing potential (30% weight) - how many votes could change outcome
    3. Turnout factor (20% weight) - smaller electorates = more volatile
    4. Category multiplier (10% weight) - flip opportunity vs retention risk

    Args:
        margin_pct: Vote margin as percentage
        total_votes: Total votes cast in race
        winner_party: Winning candidate's party (D, R, or Other)
        county: County name

    Returns:
        Vulnerability score (0-100, higher = more vulnerable)
    """
    # Normalize party
    normalized_party = normalize_party(winner_party)

    # 1. Margin tightness (40% weight)
    # Inverted sigmoid: tight margins get high scores
    # 0% margin = 100, 50% margin = ~0
    if margin_pct <= 0:
        margin_component = 100.0
    elif margin_pct >= 50:
        margin_component = 0.0
    else:
        # Non-linear: emphasize very tight races (< 5%)
        margin_component = max(0, 100 * (1 - (margin_pct / 50)))
        # Apply curve to emphasize tighter races
        if margin_pct < 5:
            margin_component = min(100, margin_component * 1.3)

    # 2. Swing potential (30% weight)
    # How many votes in dispute (both sides of margin)
    # More contested votes = more vulnerable
    swing_potential = min(100, (margin_pct / 5) * 100)  # Max at 5% margin

    # 3. Turnout factor (20% weight)
    # Smaller electorates are more volatile
    # Benchmark: county-level races typically 5k-50k votes
    # <5k votes = vulnerable to small swings
    # >50k votes = more stable
    if total_votes < 5000:
        turnout_component = 80.0
    elif total_votes < 10000:
        turnout_component = 60.0
    elif total_votes < 25000:
        turnout_component = 40.0
    elif total_votes < 50000:
        turnout_component = 20.0
    else:
        turnout_component = 10.0

    # 4. Category multiplier (10% weight)
    # Flip opportunities and retention risks warrant different weight
    # These are explicitly vulnerable categories
    if normalized_party == 'R':  # flip_opportunity
        category_multiplier = 1.0
    elif normalized_party == 'D':  # retention_risk
        category_multiplier = 1.0
    else:  # other
        category_multiplier = 0.7

    # Weighted composite score
    composite = (
        margin_component * 0.40 +
        swing_potential * 0.30 +
        turnout_component * 0.20
    )

    # Apply category multiplier to overall score
    final_score = composite * category_multiplier

    return round(min(100, max(0, final_score)), 1)


# Test cases: (margin_pct, total_votes, winner_party, description)
test_cases = [
    # Tight races (high vulnerability)
    (1.0, 10000, 'R', "Very tight R victory - flip opportunity"),
    (2.5, 8000, 'D', "Tight D victory - retention risk"),

    # Moderate races (medium vulnerability)
    (8.0, 15000, 'R', "Moderate R victory"),
    (12.0, 20000, 'D', "Moderate D victory"),

    # Blowout races (low vulnerability)
    (30.0, 25000, 'R', "R blowout victory"),
    (45.0, 30000, 'D', "D blowout victory"),

    # Small electorates (higher vulnerability due to turnout)
    (5.0, 3000, 'R', "Tight race, very small electorate"),
    (5.0, 50000, 'R', "Same margin, large electorate"),

    # Edge cases
    (0.5, 5000, 'D', "Razor-thin margin"),
    (50.0, 10000, 'R', "Maximum possible margin"),
]

print("Vulnerability Score Test Results")
print("=" * 90)
print(f"{'Description':<45} {'Margin':<10} {'Votes':<10} {'Score':<10}")
print("-" * 90)

for margin, votes, party, desc in test_cases:
    score = calculate_vulnerability_score(margin, votes, party, "TestCounty")
    print(f"{desc:<45} {margin:<10.1f}% {votes:<10} {score:<10.1f}")

print("-" * 90)
print("\nScore interpretation:")
print("  80-100: Extremely vulnerable (flip/retention at high risk)")
print("  60-80:  Very vulnerable")
print("  40-60:  Moderately vulnerable")
print("  20-40:  Less vulnerable")
print("  0-20:   Safe race")
print("\nKey insights:")
print("  1. Margin tightness dominates (40% weight)")
print("  2. Swing potential rewards contested races (30% weight)")
print("  3. Small electorates get vulnerability boost (20% weight)")
print("  4. D vs R categorization adds 10% weight")
